#include "../lib/utilities.h"
using namespace std;
using namespace cv;

cudaError_t cudaStatus;


//*********************************************************************************************************
//*********************************************************************************************************
//*********************************************************************************************************
//*********************************************************************************************************
//*********************************************************************************************************
//*************************************REMAPPING CON CUDA**************************************************
//*********************************************************************************************************
//*********************************************************************************************************
//*********************************************************************************************************
//*********************************************************************************************************


__global__ void remapping_image_cuda_kernel(float *image, int numRows, int numCols, int *tranfArray, int numChannel, float *output){
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;
    int idx = row * numCols + col;
    int homeX, homeY;
    int newhomeX, newhomeY;
    if (idx < numCols * numRows){
    //if (col < numCols && row < numRows){
        homeX=idx % numCols;
        homeY=idx / numCols; 
        if(tranfArray[idx] != -1){   
            //cout << "Index " << Idx << "Passed " << endl;
            newhomeX = tranfArray[idx] % numCols; // Col ID
            newhomeY = tranfArray[idx] / numCols;  // Row ID

            //i * col + j
            output[newhomeY * numCols + newhomeX] = image [newhomeY * numCols + newhomeX];
            if(numChannel>1)
                output[newhomeY * numCols + (newhomeX + 1)] = image [newhomeY * numCols + (newhomeX + 1)];
            
            if(numChannel>2)
                output[newhomeY * numCols + (newhomeX + 2)] = image [newhomeY * numCols + (newhomeX + 2)];
            // tranImg.at<uchar>(newhomeY, (newhomeX*channels)) = input.at<uchar>(homeY, homeX*channels);
            // if(channels>1)
            //     tranImg.at<uchar>(newhomeY, newhomeX*channels+1) = input.at<uchar>(homeY, homeX*channels+1);
            // if(channels>2)
            //     tranImg.at<uchar>(newhomeY, newhomeX*channels+2) = input.at<uchar>(homeY, homeX*channels+2);
            
        }
    }
    // Remap Image
    // for (Idx=0; Idx < size; Idx ++ ){

    //     homeX=Idx % Numcols;
    //     homeY=Idx / Numcols;                
    //     //tranImg.at<uchar>(homeY, homeX) =0;
    //     if(TransArry[Idx] != -1){   
    //         //cout << "Index " << Idx << "Passed " << endl;
    //         int newhomeX=TransArry[Idx] % Numcols; // Col ID
    //         int newhomeY=TransArry[Idx] / Numcols;  // Row ID
    //         tranImg.at<uchar>(newhomeY, (newhomeX*channels)) = input.at<uchar>(homeY, homeX*channels);
    //         if(channels>1)
    //             tranImg.at<uchar>(newhomeY, newhomeX*channels+1) = input.at<uchar>(homeY, homeX*channels+1);
    //         if(channels>2)
    //             tranImg.at<uchar>(newhomeY, newhomeX*channels+2) = input.at<uchar>(homeY, homeX*channels+2);
            
    //         }
    // }

}

/**
    restituisce in output l'immagine rimappata
*/
cv::Mat remappingImage(Mat &image, int *tranfArray){
    cudaError_t cudaStatus;
    dim3 blockDim(16, 16);
    dim3 gridDim(ceil(((float)image.cols) / blockDim.x),ceil(((float)image.rows) / blockDim.y));

    int size = image.rows * image.cols;
    Mat img = image.clone();
    cout <<"\n (float *)malloc(sizeof(float)*size) ";
    float *h_image = (float *)malloc(sizeof(float)*size);
    
    float *d_image, *d_output;

    int *d_tranfArray;
    cout <<" \n alloco il vettore sul device per l'immagine \n";
    cudaStatus = cudaMalloc((void **) &d_image, sizeof(float) * size);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto ErrorRemapping;
    }
    cout <<" \n alloco il vettore immagine per l'output\n";
    cudaStatus = cudaMalloc((void **) &d_output, sizeof(float) * size);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto ErrorRemapping;
    }
    cout <<" \n alloco il vettore di transposizione \n";
    cudaStatus = cudaMalloc((void **) &d_tranfArray, sizeof(int) * size);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto ErrorRemapping;
    }

    matToArray(h_image, image, image.rows, image.cols);

    //copio i vettori
    cudaStatus = cudaMemcpy(d_image,h_image,sizeof(float) * size, cudaMemcpyHostToDevice);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "CudaMemCpy failed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorRemapping;
    }

    cudaStatus = cudaMemcpy(d_tranfArray,tranfArray,sizeof(int) * size, cudaMemcpyHostToDevice);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "CudaMemSetfailed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorRemapping;
    }



    //__global__ void remapping_image_cuda_kernel(float *image, int numRows, int numCols, int *tranfArray, int numChannel, float *output){
    cout<<"\n RICHIAMO IL KERNELL PER IL REMAPPING DELL'IMMAGINE \n";
    //   <<<gridDim, blockDim>>>
    remapping_image_cuda_kernel<<<ceil(size/256.0),256>>>(d_image, image.rows, image.cols, d_tranfArray, image.channels(),d_output);

    cudaStatus = cudaGetLastError();
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "Kernel launch failed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorRemapping;
    }

    cout <<" \n copio il risultato del kernel \n";
    cudaStatus = cudaMemcpy(h_image,d_output,sizeof(int) * size,cudaMemcpyDeviceToHost);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "CudaMemCpy failed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorRemapping;
    }
    /**
    * converte un vettore in un oggetto Mat
    * src : array
    * dst : Mat
    */
    arrayToMat(img, h_image, size);

    return img.clone();



ErrorRemapping:
    //cout<< "****** ERRORE CUDA ****** : " << cudaStatus << endl;
    cudaFree(d_image);
    cudaFree(d_output);
    cudaFree(d_tranfArray);
    return img.clone();

}

cudaError_t warpPerspectiveCUDA(Mat input, Mat &output, const Mat H){
    // allocate array of all locations
    int Numrows = input.rows;
    int Numcols = input.cols;
    int channels   = input.channels();
    // cout << "rows " << Numrows << "col " << Numcols << "channels " << channels <<endl;
    int size = Numrows*Numcols;
    int MaxX,MaxY = -1000;
    int MinX,MinY =  1000;
    int *TransArry = (int *)malloc(sizeof(int)*size);
    int Idx;
    int homeX, homeY;

    float *d_H;
    float *vecH = (float *)malloc(sizeof(float) * H.rows * H.cols);
    int *d_T;

    Mat tranImg;
    
    cout <<" \n prima della copia della matrice H \n";
    
    cout << "tipo matrice H :" << "CV_" + type2str(H.type()) <<endl;

    matToArray(vecH, H, H.rows, H.cols);

    cout <<" \n DOPO della copia della matrice H \n";
 

    cudaStatus = cudaMalloc((void **) &d_H, sizeof(float)*H.rows * H.cols);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto ErrorWarp;
    }
    
    cudaStatus = cudaMalloc((void **) &d_T, sizeof(int) * size);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto ErrorWarp;
    }
    
    cout <<" \n copio i vettori \n";

    //copio i vettori
    cudaStatus = cudaMemcpy(d_H,vecH,sizeof(float)*H.rows * H.cols,cudaMemcpyHostToDevice);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "CudaMemCpy failed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorWarp;
    }
    cudaStatus = cudaMemset(d_T, 0, sizeof(int) * size);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "CudaMemSetfailed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorWarp;
    }
    // 
    // dim3 blockDim(16, 16);
    // dim3 gridDim(ceil(((float)numAColumns) / blockDim.x),ceil(((float)numBRows) / blockDim.y));
    // 
    //ceil(n/256.0),256
    //dim3 DimGrid(ceil(size/256.0),1,1);
    //dim3 DimBlock(256,1,1);

    cout <<" \n richiamo il kernell per il calcolo dell'array \n";
    calc_tranf_array<<<ceil(size/256.0),256>>>(d_H, d_T, input.rows, input.cols);
    
    cudaStatus = cudaGetLastError();
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "Kernel launch failed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorWarp;
    }

    cout <<" \n copio il risultato del kernel \n";
    cudaStatus = cudaMemcpy(TransArry,d_T,sizeof(int) * size,cudaMemcpyDeviceToHost);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "CudaMemCpy failed: %s\n", cudaGetErrorString(cudaStatus));
        goto ErrorWarp;
    }
    

    //input.copyTo(tranImg);
    tranImg = input.clone();
    tranImg = tranImg - tranImg;
    
    //cv::Mat remappingImage(Mat &image, int *tranfArray)
    
    cout <<" \n richiamo la funzione per il remapping \n";
    output = remappingImage(tranImg, TransArry);
    
    // Remap Image
    // for (Idx=0; Idx < size; Idx ++ ){

    //     homeX=Idx % Numcols;
    //     homeY=Idx / Numcols;                
    //     //tranImg.at<uchar>(homeY, homeX) =0;
    //     if(TransArry[Idx] != -1){   
    //         //cout << "Index " << Idx << "Passed " << endl;
    //         int newhomeX=TransArry[Idx] % Numcols; // Col ID
    //         int newhomeY=TransArry[Idx] / Numcols;  // Row ID
    //         tranImg.at<uchar>(newhomeY, (newhomeX*channels)) = input.at<uchar>(homeY, homeX*channels);
    //         if(channels>1)
    //             tranImg.at<uchar>(newhomeY, newhomeX*channels+1) = input.at<uchar>(homeY, homeX*channels+1);
    //         if(channels>2)
    //             tranImg.at<uchar>(newhomeY, newhomeX*channels+2) = input.at<uchar>(homeY, homeX*channels+2);
            
    //         }
    // }


   
    //output = tranImg.clone();

ErrorWarp:
    //cout<< "****** ERRORE CUDA ****** : " << cudaStatus << endl;
    cudaFree(d_H);
    cudaFree(d_T);
    
    return cudaStatus;
}





